谈到 Scheme 的独特之处，除了它那极简语法的 s-expression 外，就是与众不同但又威力强大的宏，或者说是语法拓展（syntax-extension）了。本文除了作为我对 syntax-rules 的学习总结之外，其实更多的是对宏这一机制的理解与思考。

我目前学过 C、scheme、python，对 perl 和 javascrpit 有所了解，以我浅薄的编程学习经历来看，这些语言中貌似只有 C（C++） 和 scheme 中有宏这个东西。而这也许说明宏并不是什么好东西。文中的例子将使用这两种语言。

本文的内容包括对宏的简单介绍，一些使用宏的例子，以及对 syntax-rules 的简单介绍。Scheme 中还有许多其他的宏机制，如 syntax-case，explicit renaming 和 syntactic closures 等，但 syntax-rules 是 Scheme 标准中规定实现的，其他宏机制将在之后的文章中进行介绍。

让我们从对宏的基本认识开始这篇文章吧。

# 什么是宏

参考维基百科【2】，宏的定义如下：

在计算机科学中，**宏** （macro，macroinstruction）是一种规则或模式，用于指定如何将某个输出序列（通常是字符序列）根据定义的过程来映射到替换输出序列（通常也是字符序列）。将宏实例化为特定序列的映射过程称为宏展开（macro expansion）。

宏被用来将一连串的计算机指令作为一条程序语句提供给程序员，使编程任务不那么琐碎（这也就是为什么它们被叫做“宏”，因为一**大**块代码可以使用一小**串**字符序列通过展开得到）

## 宏的分类

维基百科上的分类略有些繁杂，有键盘宏，脚本宏，参数宏，过程宏，词法宏等等。这里采用参考资料【3】的分类方法，根据是否使用模式匹配将宏分为过程宏和高级宏，根据宏的卫生性将宏分为卫生宏（hygienic macro）和非卫生宏。

### 过程宏与高级宏

过程宏，根据【3】的定义，类似于一个普通的函数，输入一个表达式并输出一个表达式，比如交换两个变量的值，在 C 中使用宏可以这样做：（这里当然可以用 `do while(0)`）

```c
#define SWAP(x, y) \
{                  \
    int a = x;     \
    x = y;         \
    y = a;         \
}


SWAP(a1 ,a2) =>
{int a = a1; a1 = a2; a2 = a;}
```

在 scheme 中可以这样做：

```scheme
(define-syntax SWAP
 (syntax-rules()
    [(_ x y)
     (let ([a x])
       (set! x y)
       (set! y a))]))

(SWAP a1 a2) =>
(let ([a a1])
   (set! a1 a2)
   (set! a2 a))
```

从上面这个例子是体现不出 scheme 宏的高级性的。高级宏的强大之处体现在模式匹配上。模式匹配从更高的层次描述输入与输出的关系，通过使用模式匹配，一个表达式可以变换成另一个表达式而不是直接输出。

假设我们现在需要一个与宏，它可以对一个或多个参数进行逻辑与操作，若参数个数为 0，则输出真。以我目前的 C 语言水平貌似做不到这一点。看看在 Scheme 中如何完成这个任务：

```scheme
(define-syntax AND
   (syntax-rules()
     [(_) #t]
     [(_ e1) e1]
     [(_ e1 e2 e3 ...)
      (if e1 (and e2 e3 ...) #f)]))
```

通过模式匹配，这个宏可以轻松应对不同参数的情况。在这个宏中还用到了宏的递归展开，而这在 C 的宏中是难以想象的（或者说是我难以想象的）。

## 卫生宏和非卫生宏

> 卫生和非卫生的本质问题是作用域问题 —— 摘自参考资料【3】

卫生宏的展开保证不会出现意外的标识符捕获。它的好处在于，一旦宏的定义完成，那么宏展开的结果就已经是可以确定的了，它的展开结果不会随调用地点的改变而改变，这与静态作用域的特点非常相似。

宏有宏定义阶段和宏展开阶段，卫生宏弄清了哪些符号对应于宏定义阶段，哪些符号对应于宏展开阶段。如果宏是卫生的，它就具有“引用透明性”，定义阶段确定的符号意义不会在展开阶段出现意外的绑定。非卫生宏只是进行表达式的直接替换，而卫生宏需要理解语义，理解每个符号所处的环境。

还是以上面的变量交换代码来作为例子，如果我使用变量 `a, b` 调用 Ｃ 的宏，展开结果如下：

```c
SWAP(a, b) => {int a = a; a = b; b = a;}
```

很明显，上面的代码是有问题的，`int a = a` 不是一个良好的定义语句，原本应作为临时变量的 a 与作为宏参数的 a 重名了。

要想解决这个问题，可以把临时变量的名字修改成更加复杂和不常见的名字。但是这只能降低重名的风险，而不是彻底解决掉这个隐患。

那么，上面的 scheme 宏是否存在这个问题呢？在 chez-scheme 中使用 expand 过程来观察宏展开，你会得到类似如下的结果：

```scheme
(SWAP a b)
=>
(let ([#{a a36te8sjq7qytr0trgpami01o44cyl9c-0} a])
  (set! a b)
  (set! b #{a a36te8sjq7qytr0trgpami01o44cyl9c-0}))
```

出现在 let 中的变量并不是 a，而是另一个变量，它的名字与宏参数 a 不同，因此不存在名字碰撞的问题。

# 参考资料

【1】为什么Lisp语言如此先进？（译文）： https://www.ruanyifeng.com/blog/2010/10/why_lisp_is_superior.html

【2】Macro (computer science) From Wikipedia, the free encyclopedia： https://en.wikipedia.org/wiki/Macro_(computer_science)

【3】scheme 卫生宏实现介绍： http://www.zenlife.tk/scheme-hygiene-macro.md
